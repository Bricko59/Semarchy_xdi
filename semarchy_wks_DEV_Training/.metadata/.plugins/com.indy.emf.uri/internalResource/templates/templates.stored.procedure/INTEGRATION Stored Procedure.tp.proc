<?xml version="1.0" encoding="UTF-8"?>
<proc:process xmlns:proc="http://www.example.org/proc" description="This template is used to call stored procedures on rdbms servers&#xD;&#xA;&#xD;&#xA;Prerequisites:&#xD;&#xA;- Runtime S17.3.0 or higher&#xD;&#xA;&#xD;&#xA;History:&#xD;&#xA;05/09/2019&#x9;Template was not working on Java Versions prior to Java 8&#xD;&#xA;19/04/2019  Initialize template history" id="_3LjdoUdBEemY2or4OqFeDQ" metaInf="">
  <subProcess id="_3LjdrUdBEemY2or4OqFeDQ" isBeginAction="false" name="INT" nbCycles="-1" toleratedError="false">
    <actionCode id="_3LjdrkdBEemY2or4OqFeDQ" isBeginAction="false" name="BeanShell" nbCycles="-1" toleratedError="false" technology="com.indy.engine.actionCodes.BeanScriptingActionCodeI">
      <link id="_3Ljdr0dBEemY2or4OqFeDQ" executionType="OK" generationType="OK_KO" mandatory="1" targetId="_3Ljdt0dBEemY2or4OqFeDQ"/>
      <parameter id="_3LjdsEdBEemY2or4OqFeDQ" name="SCRIPTING_LANGUAGE" type="String" value="beanshell"/>
      <parameter id="_3LjdsUdBEemY2or4OqFeDQ" name="SCRIPTING_CONNECTION" type="String" value="%x{$this/../@id}x%"/>
      <parameter id="_3LjdskdBEemY2or4OqFeDQ" name="SQL_CONNECTION" type="Boolean" value="true"/>
      <code>import java.lang.Integer;&#xD;
import java.lang.Exception;&#xD;
import java.sql.ResultSet;&#xD;
import java.util.Map;&#xD;
import java.util.List;&#xD;
import java.util.TreeMap;&#xD;
&#xD;
var errorCount=0;&#xD;
var debug=0;&#xD;
var STR_PROCTYPE_STD=&quot;standard&quot;;&#xD;
var STR_PROCTYPE_RS=&quot;resultSet&quot;;&#xD;
&#xD;
var __handler__=new com.indy.engine.common.tools.impl.JavaObjectHandler(){&#xD;
&#xD;
	batchSize(){&#xD;
		return 1;&#xD;
	}&#xD;
	&#xD;
	init(Map properties, var handler){}&#xD;
	&#xD;
	close(){}&#xD;
	&#xD;
	handleObject(List o, var statHandler){&#xD;
		var nbParams=0;&#xD;
		var hasInputParams=false;&#xD;
		var hasOutputParams=false;&#xD;
		String procType=STR_PROCTYPE_STD;&#xD;
		//String procName = &quot;%x{$REF/ref:target()/@name}x%&quot;;&#xD;
		String procName = &quot;%x{$REF/ref:target()/ref:server()/tech:addDelimiter($REF/ref:target()/@name)}x%&quot;;&#xD;
			&#xD;
		inputMap=o.get(0);&#xD;
		&#xD;
		if (debug==1){&#xD;
			print(&quot;input : &quot; + o);&#xD;
		}&#xD;
		if (procName.equalsIgnoreCase(&quot;&quot;))&#xD;
		{&#xD;
			throw new Exception(&quot;A Procedure name cannot be empty&quot;);&#xD;
		}&#xD;
		&#xD;
		Map cInParamDataTypes=new TreeMap();&#xD;
		Map cOutParamDataTypes=new TreeMap();&#xD;
		Map cOutColumnDataTypes=new TreeMap();&#xD;
		&#xD;
		if (debug==1){&#xD;
			print(&quot;todo : handle case when tech:sqlJavaTypeConstant is null/empty&quot;);&#xD;
		}&#xD;
		%x{md:list($REF/ref:target()/inputParameter/concat('cInParamDataTypes.put(&quot;',@name,'&quot;,',ref:sqlDataType()/ref:superType()/tech:sqlJavaTypeConstant(),');'),'\n')}x%&#xD;
		%x{md:list($REF/ref:target()/outputParameter/concat('cOutParamDataTypes.put(&quot;',@name,'&quot;,',ref:sqlDataType()/ref:superType()/tech:sqlJavaTypeConstant(),');'),'\n')}x%&#xD;
		%x{md:list($REF/ref:target()/outputSet/outputRow/outputColumn/concat('cOutColumnDataTypes.put(&quot;',@name,'&quot;,',ref:sqlDataType()/ref:superType()/tech:sqlJavaTypeConstant(),');'),'\n')}x%&#xD;
		List inputParamsList = new ArrayList();&#xD;
		List outputParamsList = new ArrayList();&#xD;
		HashMap allParamsMap = new HashMap();&#xD;
		%xsl{&#xD;
			&lt;xsl:variable name=&quot;orderedParameters&quot;>&#xD;
			&lt;xsl:value-of select=&quot;concat('int __i = 1;', codepoints-to-string(10))&quot;/>&#xD;
			&lt;xsl:for-each select=&quot;$REF/ref:target()/*[name()='inputParameter' or name()='outputParameter']&quot;>&#xD;
				&lt;xsl:sort select=&quot;position()&quot; />&#xD;
				&lt;xsl:choose>&#xD;
					&lt;xsl:when test=&quot;name()='inputParameter' &quot;>&#xD;
						&lt;xsl:value-of select=&quot;concat('inputParamsList.add(', codepoints-to-string(34), @name, codepoints-to-string(34), ');', codepoints-to-string(10))&quot;/>&#xD;
					&lt;/xsl:when>&#xD;
					&lt;xsl:when test=&quot;name()='outputParameter' &quot;>&#xD;
						&lt;xsl:value-of select=&quot;concat('outputParamsList.add(', codepoints-to-string(34), @name, codepoints-to-string(34), ');', codepoints-to-string(10))&quot;/>&#xD;
					&lt;/xsl:when>&#xD;
				&lt;/xsl:choose>&#xD;
				&lt;xsl:value-of select=&quot;concat('allParamsMap.put(', codepoints-to-string(34), @name, codepoints-to-string(34), ', __i++);', codepoints-to-string(10))&quot;/>&#xD;
			&lt;/xsl:for-each>&#xD;
			&lt;/xsl:variable>&#xD;
			%x{$orderedParameters}x%&#xD;
		}xsl%&#xD;
		&#xD;
		String[] outputColumns = &quot;%x{md:sortedList($REF/ref:target()/outputSet/outputRow/outputColumn/concat(@position,' ',@name),',')}x%&quot;.split(&quot; &quot;);&#xD;
		&#xD;
		if (inputParamsList.size()!=0)&#xD;
		{&#xD;
			hasInputParams=true;&#xD;
		}&#xD;
		if (outputParamsList.size()!=0)&#xD;
		{&#xD;
			hasOutputParams=true;&#xD;
		}&#xD;
		if (outputColumns[0].length()!=0)&#xD;
		{&#xD;
			procType=STR_PROCTYPE_RS;&#xD;
		}&#xD;
		int nbParams = inputParamsList.size() + outputParamsList.size();&#xD;
		String paramProcedureString = &quot;&quot;;&#xD;
&#xD;
		if (hasInputParams)&#xD;
		{&#xD;
			for(Iterator it = inputParamsList.iterator(); it.hasNext();){&#xD;
				Object v = it.next();&#xD;
				if (!inputMap.containsKey(v)){&#xD;
					it.remove();&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
		&#xD;
		for (int i = 1; i &lt;= inputParamsList.size() + outputParamsList.size() ; i++) {&#xD;
			if(i != nbParams){&#xD;
				paramProcedureString += &quot;?,&quot;;&#xD;
			}&#xD;
			else{&#xD;
				paramProcedureString += &quot;?&quot;;&#xD;
			}&#xD;
		}&#xD;
		if (debug==1){&#xD;
			print(&quot;nb params for &quot; + procName + &quot; : &quot; + allParamsMap.size() + &quot; parameter(s)&quot;);&#xD;
			print(&quot;processing type &quot; + procType);&#xD;
		}&#xD;
		var cstmt = null;&#xD;
&#xD;
	 	try {&#xD;
		 	if (debug==1){&#xD;
		 		print(&quot;TODO : Handle schema&quot;);&#xD;
		 	}&#xD;
		 	&#xD;
		 	// prepare call with defined params&#xD;
		 	String defaultName = &quot;%x{$REF/ref:target()/ref:server()/tech:default()}x%&quot;;&#xD;
		 	String callString = &quot;{call &quot; + defaultName + &quot;.&quot; + procName + &quot;(&quot; + paramProcedureString + &quot;)}&quot;;&#xD;
		 	&#xD;
			if (debug==1){&#xD;
				print(callString);&#xD;
		 	}&#xD;
		 	&#xD;
	        cstmt = con.prepareCall(callString);&#xD;
	        &#xD;
	        if(hasInputParams){&#xD;
	        	// binding input params to call procedure&#xD;
	        	int index = 1;&#xD;
		       	Iterator itInput = inputParamsList.iterator();&#xD;
			    while (itInput.hasNext()) {&#xD;
				    String name = itInput.next();&#xD;
				    if (debug==1){&#xD;
				    	print(&quot;index  = &quot; + index);&#xD;
				    	print(&quot;cstmt.getObject &quot; + name + &quot; = &quot; + cInParamDataTypes.get(name));&#xD;
				    	print(&quot;value ?  &quot; + inputMap.get(name));&#xD;
				    }&#xD;
				    switch (cInParamDataTypes.get(name)) {&#xD;
			            case java.sql.Types.CHAR:&#xD;
			            case java.sql.Types.NCHAR:&#xD;
			            case java.sql.Types.VARCHAR:&#xD;
			            case java.sql.Types.LONGVARCHAR:&#xD;
			                cstmt.setString(name, inputMap.get(name));&#xD;
			                break;&#xD;
			                &#xD;
			            case java.sql.Types.NUMERIC:&#xD;
			            case java.sql.Types.DECIMAL:&#xD;
			            	if (inputMap.get(name) instanceof java.math.BigInteger){&#xD;
			            		cstmt.setDouble(name, inputMap.get(name).doubleValue());&#xD;
			            	} else {&#xD;
			            		cstmt.setDouble(name, inputMap.get(name));&#xD;
			            	}&#xD;
			                break;&#xD;
			                &#xD;
			            case java.sql.Types.INTEGER:&#xD;
			            	if (inputMap.get(name) instanceof java.math.BigInteger){&#xD;
			            		cstmt.setDouble(name, inputMap.get(name).doubleValue());&#xD;
			            	} else {&#xD;
			            		cstmt.setInt(name, inputMap.get(name));&#xD;
			            	}&#xD;
			                break;&#xD;
			                &#xD;
			            case java.sql.Types.BIGINT:&#xD;
			                cstmt.setDouble(name, inputMap.get(name).doubleValue());&#xD;
			                break;&#xD;
			                &#xD;
			            case java.sql.Types.LONGVARBINARY:&#xD;
			            case java.sql.Types.VARBINARY:&#xD;
			            case java.sql.Types.BINARY:&#xD;
			                cstmt.setBytes(name, inputMap.get(name));&#xD;
			                break;&#xD;
			                &#xD;
			            case java.sql.Types.BLOB:&#xD;
			                cstmt.setBlob(name, inputMap.get(name));&#xD;
			                break;&#xD;
			                &#xD;
						case java.sql.Types.BOOLEAN:&#xD;
			                cstmt.setBoolean(name, inputMap.get(name));&#xD;
			                break;&#xD;
			                &#xD;
						case java.sql.Types.DATE:&#xD;
			                cstmt.setDate(name, new java.sql.Date(inputMap.get(name).getTime()));&#xD;
			                break;&#xD;
			                &#xD;
						case java.sql.Types.DOUBLE:&#xD;
			                cstmt.setDouble(name, inputMap.get(name));&#xD;
			                break;&#xD;
			                &#xD;
						case java.sql.Types.FLOAT:&#xD;
							if (inputMap.get(name) instanceof java.lang.String){&#xD;
			            		cstmt.setFloat(name, Float.parseFloat(inputMap.get(name)));&#xD;
			            	} else {&#xD;
			            		cstmt.setFloat(name, inputMap.get(name));&#xD;
			            	}&#xD;
			                break;&#xD;
			                &#xD;
						case java.sql.Types.TIME:&#xD;
							cstmt.setTime(name, new java.sql.Time(inputMap.get(name).getTime()));&#xD;
			                break;&#xD;
			                &#xD;
						case java.sql.Types.TIMESTAMP:&#xD;
							java.sql.Timestamp ts = new java.sql.Timestamp(inputMap.get(name).toInstant().toEpochMilli());							&#xD;
			                cstmt.setTimestamp(name, ts );&#xD;
			                break;	&#xD;
			                                &#xD;
						default: &#xD;
							cstmt.setObject(name, inputMap.get(name));&#xD;
							break;&#xD;
					}&#xD;
				    index++;&#xD;
				}&#xD;
	        }&#xD;
		 	if(hasOutputParams){&#xD;
		 		// register output params to call procedure&#xD;
			 	Iterator itOutput = outputParamsList.iterator();&#xD;
			 	while (itOutput.hasNext()) {&#xD;
				    String value = (String)itOutput.next();&#xD;
				    if (debug==1){&#xD;
				    	print(&quot;value output = &quot; + value);&#xD;
				    }&#xD;
				    if (outputParamsList.contains(value)){&#xD;
				    	cstmt.registerOutParameter(value, cOutParamDataTypes.get(value));&#xD;
				    }&#xD;
				    &#xD;
				}&#xD;
		 	}&#xD;
		 	// call procedure&#xD;
	        cstmt.execute();&#xD;
	        	if (procType.equalsIgnoreCase(STR_PROCTYPE_RS)){&#xD;
				// get output rows and columns from resultSet and put in output object&#xD;
				ResultSet rs;&#xD;
				try &#xD;
				{&#xD;
				rs = cstmt.getResultSet();&#xD;
				if(rs == null){ &#xD;
					// some databases, at least HSQL, requires this to be executed before retrieving result set&#xD;
					if(cstmt.getMoreResults()){ &#xD;
						rs = cstmt.getResultSet();
					}&#xD;
				}&#xD;
				&#xD;
				outputSet=new ArrayList();&#xD;
				while (rs.next()){&#xD;
						outputRow=new HashMap();&#xD;
						for (int i = 0; i &lt; outputColumns.length; i++) {&#xD;
							// print(&quot;rsGetObject &quot; + outputColumns[i] + &quot; = &quot; + cOutColumnDataTypes.get(outputColumns[i]));&#xD;
							switch (cOutColumnDataTypes.get(outputColumns[i])) {&#xD;
					            case java.sql.Types.CHAR:&#xD;
					            case java.sql.Types.NCHAR:&#xD;
					            case java.sql.Types.VARCHAR:&#xD;
					            case java.sql.Types.LONGVARCHAR:&#xD;
					            	outputRow.put(outputColumns[i],rs.getString(outputColumns[i]));&#xD;
					                break;&#xD;
					                &#xD;
					            case java.sql.Types.NUMERIC:&#xD;
					            case java.sql.Types.DECIMAL:&#xD;
					            	outputRow.put(outputColumns[i],rs.getBigDecimal(outputColumns[i]));&#xD;
					                break;&#xD;
					                &#xD;
					            case java.sql.Types.INTEGER:&#xD;
					            	outputRow.put(outputColumns[i],rs.getInt(outputColumns[i]));&#xD;
					                break;&#xD;
					                &#xD;
					            case java.sql.Types.BIGINT:&#xD;
					            	outputRow.put(outputColumns[i],rs.getDouble(outputColumns[i]));&#xD;
					                break;&#xD;
					                &#xD;
					            case java.sql.Types.LONGVARBINARY:&#xD;
					            case java.sql.Types.VARBINARY:&#xD;
					            case java.sql.Types.BINARY:&#xD;
					            	outputRow.put(outputColumns[i],rs.getBytes(outputColumns[i]));&#xD;
					                break;&#xD;
					                &#xD;
					            case java.sql.Types.BLOB:&#xD;
					            	outputRow.put(outputColumns[i],rs.getBlob(outputColumns[i]));&#xD;
					                break;&#xD;
					                &#xD;
								case java.sql.Types.BOOLEAN:&#xD;
									outputRow.put(outputColumns[i],rs.getBoolean(outputColumns[i]));&#xD;
					                break;&#xD;
					                &#xD;
								case java.sql.Types.DATE:&#xD;
									outputRow.put(outputColumns[i],rs.getDate(outputColumns[i]));&#xD;
					                break;&#xD;
					                &#xD;
								case java.sql.Types.DOUBLE:&#xD;
									outputRow.put(outputColumns[i],rs.getDouble(outputColumns[i]));&#xD;
					                break;&#xD;
					                &#xD;
								case java.sql.Types.FLOAT:&#xD;
									outputRow.put(outputColumns[i],rs.getFloat(outputColumns[i]));&#xD;
					                break;&#xD;
					                &#xD;
								case java.sql.Types.TIME:&#xD;
									outputRow.put(outputColumns[i],rs.getTime(outputColumns[i]));&#xD;
					                break;&#xD;
					                &#xD;
								case java.sql.Types.TIMESTAMP:&#xD;
									outputRow.put(outputColumns[i],rs.getTimestamp(outputColumns[i]));&#xD;
					                break;	&#xD;
					                &#xD;
								default: &#xD;
									outputRow.put(outputColumns[i],rs.getObject(outputColumns[i]));&#xD;
									break;&#xD;
							}&#xD;
						}&#xD;
						outputSet.add(outputRow);&#xD;
					}&#xD;
					inputMap.put(&quot;outputSet&quot;,outputSet);&#xD;
				} catch (Exception ex) {&#xD;
					errorCount = 1;&#xD;
						throw new Exception(&quot;Error while trying to process the resultset from the procedure: &quot; + procName, ex);&#xD;
				} finally {&#xD;
					if (rs != null) {&#xD;
						try {&#xD;
							rs.close();&#xD;
						} catch (SQLException ex) {&#xD;
							errorCount = 1;&#xD;
							throw new Exception(&quot;Error while trying to close the resultset from the procedure: &quot; + procName, ex);&#xD;
						}&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
	        if (hasOutputParams){&#xD;
	        	// get output param values and put in output object&#xD;
		        Iterator itOutput = outputParamsList.iterator();&#xD;
			 	while (itOutput.hasNext()) {&#xD;
				    String value = (String)itOutput.next();&#xD;
				   // print(&quot;output param debug &quot; + value + &quot; = &quot; + cOutParamDataTypes.get(value));&#xD;
				    switch (cOutParamDataTypes.get(value)) {&#xD;
			            case java.sql.Types.CHAR:&#xD;
			            case java.sql.Types.NCHAR:&#xD;
			            case java.sql.Types.VARCHAR:&#xD;
			            case java.sql.Types.LONGVARCHAR:&#xD;
			            	inputMap.put(value,cstmt.getString(value));&#xD;
			                break;&#xD;
			                &#xD;
			            case java.sql.Types.NUMERIC:&#xD;
			            case java.sql.Types.DECIMAL:&#xD;
			            	inputMap.put(value,cstmt.getBigDecimal(value));&#xD;
			                break;&#xD;
			                &#xD;
			            case java.sql.Types.INTEGER:&#xD;
			            	inputMap.put(value,cstmt.getInt(value));&#xD;
			                break;&#xD;
			                &#xD;
			            case java.sql.Types.BIGINT:&#xD;
			            	inputMap.put(value,cstmt.getDouble(value));&#xD;
			                break;&#xD;
			                &#xD;
			            case java.sql.Types.LONGVARBINARY:&#xD;
			            case java.sql.Types.VARBINARY:&#xD;
			            case java.sql.Types.BINARY:&#xD;
			            	inputMap.put(value,cstmt.getBytes(value));&#xD;
			                break;&#xD;
			                &#xD;
			            case java.sql.Types.BLOB:&#xD;
			            	inputMap.put(value,cstmt.getBlob(value));&#xD;
			                break;&#xD;
			                &#xD;
						case java.sql.Types.BOOLEAN:&#xD;
							inputMap.put(value,cstmt.getBoolean(value));&#xD;
			                break;&#xD;
			                &#xD;
						case java.sql.Types.DATE:&#xD;
							inputMap.put(value,cstmt.getDate(value));&#xD;
			                break;&#xD;
			                &#xD;
						case java.sql.Types.DOUBLE:&#xD;
							inputMap.put(value,cstmt.getDouble(value));&#xD;
			                break;&#xD;
			                &#xD;
						case java.sql.Types.FLOAT:&#xD;
							inputMap.put(value,cstmt.getFloat(value));&#xD;
			                break;&#xD;
			                &#xD;
						case java.sql.Types.TIME:&#xD;
							inputMap.put(value,cstmt.getTime(value));&#xD;
			                break;&#xD;
			                &#xD;
						case java.sql.Types.TIMESTAMP:&#xD;
							inputMap.put(value,cstmt.getTimestamp(value));&#xD;
			                break;	&#xD;
			                &#xD;
						default: &#xD;
							inputMap.put(value,cstmt.getObject(value));&#xD;
							break;&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
			&#xD;
	    } catch (Exception ex) {&#xD;
	        errorCount = 1;&#xD;
	        throw new Exception(&quot;An error occurred while executing a stored procedure.&quot;, ex);&#xD;
	    } finally {&#xD;
	        if (cstmt != null) {&#xD;
	            try {&#xD;
	                cstmt.close();&#xD;
	            } catch (SQLException ex) {&#xD;
	               errorCount = 1;&#xD;
	               throw new Exception(&quot;Error while trying to close a callable statement.&quot;, ex);&#xD;
	            }&#xD;
	        }&#xD;
	    }&#xD;
	    if (debug==1){&#xD;
		    print(&quot;o : &quot; + o);&#xD;
	    }    &#xD;
		return o;&#xD;
	}&#xD;
&#xD;
};</code>
    </actionCode>
    <actionCode id="_3Ljds0dBEemY2or4OqFeDQ" isBeginAction="false" name="Connect" nbCycles="-1" toleratedError="false" technology="com.indy.engine.actionCodes.BeanScriptingActionCodeI">
      <link id="_3LjdtEdBEemY2or4OqFeDQ" executionType="OK" generationType="OK_KO" mandatory="1" targetId="_3LjdrkdBEemY2or4OqFeDQ"/>
      <parameter id="_3LjdtUdBEemY2or4OqFeDQ" name="SCRIPTING_LANGUAGE" type="String" value="beanshell"/>
      <parameter id="_3LjdtkdBEemY2or4OqFeDQ" name="SCRIPTING_CONNECTION" type="String" value="%x{$this/../@id}x%"/>
      <code>cl = com.indy.engine.core.module.classloader.ClassLoaderServiceProvider.INSTANCE.getClassLoader(&quot;%x{$REF/ref:target()/ref:server()/tech:module()}x%&quot;,&quot;%x{$REF/ref:target()/ref:server()/tech:jdbcDriver()}x%&quot;);&#xD;
clazz = Class.forName(&quot;%x{$REF/ref:target()/ref:server()/tech:jdbcDriver()}x%&quot;, true, cl);&#xD;
drv = clazz.newInstance();&#xD;
&#xD;
Properties props = new Properties();&#xD;
props.setProperty(&quot;user&quot;,&quot;%x{$REF/ref:target()/ref:server()/tech:jdbcUser()}x%&quot;);&#xD;
props.setProperty(&quot;password&quot;,&quot;%x{$REF/ref:target()/ref:server()/tech:jdbcPassword()}x%&quot;);&#xD;
&#xD;
con = drv.connect(&quot;%x{$REF/ref:target()/ref:server()/tech:jdbcUrl()}x%&quot;,props);&#xD;
</code>
    </actionCode>
    <actionProcessRef id="_3Ljdt0dBEemY2or4OqFeDQ" enable="true" isBeginAction="false" name="INT" nbCycles="-1" toleratedError="false" targetName="../../addons/generic/templates/templates.generic/Xml/INTEGRATION%20Rdbms%20to%20Xml.proc#_1b6fEK6lEd6tEoMWC9noQg?fileId=_brHmkaEoEd6xg_kipsVRYg$type=proc$name=INT?">
      <parameter id="_3LjduEdBEemY2or4OqFeDQ" name="streamHook01" type="String" value="class=com.indy.engine.common.tools.impl.JavaGenericOutputStreamTransformer&#xD;&#xA;script.handler.language.name=beanshell&#xD;&#xA;script.handler.connection.name=%x{$this/../@id}x%&#xD;&#xA;script.handler.object.name=__handler__&#xD;&#xA;"/>
    </actionProcessRef>
    <templateType>I-TP.RDBMS.INTEGRATING</templateType>
  </subProcess>
  <templateType>I-TP.RDBMS</templateType>
</proc:process>